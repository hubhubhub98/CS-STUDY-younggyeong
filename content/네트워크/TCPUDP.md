# 전송 계층
전송 계층은 송신자와 수신자를 연결하는 통신서비스를 제공하며 연결지향 데이터 스트림 지원, 신뢰성, 흐름제어를 제공하며, 애플리케이션과 인터넷계층 사이의 데이터가 전달될 때의 중계 역할을 한다.   
대표적으로 TCP와 UDP가 있다.

# TCP
TCP는 패킷 사이의 순서를 보장하고 연결지향 프로토콜을 사용해 연결을 하며 신뢰성을 구축해서 수신여부를 학인하는 **가상회선 패킷 교환 방식** 을 사용한다.
TCP는 네트워크 정보 전달을 통제하는 프로토콜이자, 인터넷을 이루는 핵심 프로토콜이다.

## 가상회선 패킷 교환 방식
![image](https://user-images.githubusercontent.com/54929520/186431876-03385ff4-8638-45f0-b76e-036e2be9fd02.png)  
위 그림과 같이 각 패킷에 가상회선 식별자가 포함되며 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 **순서대로** 도착하는 방식이다.  
**패킷이란?** 인터넷 내에서 데이터를 보내기 위한 경로배정(라우팅)을 효율적으로 하기 위해서 데이터를 여러 개의 조각들로 나누어 전송을 하는데 이때, 이 조각을 패킷이라고 한다.

## TCP의 특징
1. **연결형 서비스**로 가상 회선 방식을 제공한다.
2. **3-way handshaking과정을 통해 연결을 설정**하고 **4-way handshaking을 통해 해제**한다.
3. **흐름 제어** 및 **혼잡 제어**.
4. **높은 신뢰성**을 보장한다.
5. UDP보다 속도가 느리다.
6. 전이중(Full-Duplex), 점대점(Point to Point) 방식.

# 연결 설정(3-WAY HANDSHAKING)
TCP는 신뢰성을 확보할 때, 3-웨이 핸드쉐이크 작업을 진행한다.

![image](https://user-images.githubusercontent.com/54929520/186432978-0c1bc7df-ea74-41e8-bdb1-283c50dcf513.png)  
1. **SYN 단계** : 클라이언트가 서버에 클라이언트의 ISN(12010)을 담아 SYN을 보낸다. ISN은 새로운 TCP 연결의 첫 번째 패킷에 할당된 임이의 시퀀스 번호를 말한다.
2. **SYN+ACK 단계** : 서버는 클라이언트의 SYN을 수신하고 서버의 ISN(5000)을 보내며 승인번호로 클라이언트의 ISN+1(12011)을 보낸다.
3. **ACK 단계** : 클라이언트는 서버의 ISN+1(5001)한 값인 승인번호를 담아 ACK를 서버에 보낸다.

### 전이중 통신의 구성
**1,2번 단계를 통해** C->S 방향에 대한 연결 파라미터(시퀀스 번호)를 설정하고 승인.  
**2,3번 단계를 통해** S->C 방향에 대한 연결 파라미터(시퀀스 번호)를 설정하고 승인.  
-> 이를 통해 전이중(full-duplec) 통신이 구성된다.  

위 방식대로 3-웨이 핸드셰이크 과정 이후 신뢰성이 구축되고 데이터 전송을 시작한다.   
TCP는 이 과정이 있기에 신뢰성있는 계층이라고 하며 UDP는 이 과정이 없기에 신뢰성이 없는 계층이라고 한다.

|용어|의미|
|----|----|
|SYN|SYNchronization의 약자. 연결 요청 플래그|
|ACK|ACKnowledgement의 약자. 응답 플래그|
|ISN|Initial Sequence Number의 약어. 초기 네트워크 연결을 할 때 할당된 32비트 고유 시퀀스 번호이다.|

# 연결 해제
TCP가 연결을 해제할 때는 두 가지 경우가 있다.
1. 갑작스러운 연결 해제
2. 정상적인 연결 해제(4-WAY HANDSHAKING)

### 갑작스런 연결 해제

**RST(TCP reset) 세그먼트**가 전송되면 갑작스러운 연결 해제가 수행되는데, RST 세그먼트는 다음과 같은 경우에 전송된다.

1. 존재하지 않는 TCP 연결에 대해 비SYN 세그먼트가 수신된 경우 RST 세그먼트를 보내, 해당 커넥션을 닫아 공격을 방지한다.
2. 열린 커넥션에서 잘못된 헤더가 있는 세그먼트가 수신된 경우 RST 세그먼트를 보내, 해당 커넥션을 닫아 공격을 방지한다.
3. 연결을 지원하는 리소스가 부족할때
4. 원격 호스트에 연결할 수 없고 응답이 중지되었을때

### 정상적인 연결 해제(4-WAY HANDSHAKING)
TCP가 연결을 해제할 때는 4-웨이 핸드쉐이크 과정이 발생한다.
![image](https://user-images.githubusercontent.com/54929520/186434592-fe30d6a1-3163-46fb-b3b5-a5d675328326.png)

1번 : 먼저 클라이언트가 연결을 닫으려고 할 때 FIN으로 설정된 세그먼트를 보낸다. 그리고 클라이언트는 FIN_WAIT_1 상태로 들어가 서버의 응답을 기다린다.  
2번 : 서버는 클라이언트로 ACK라는 승인 세그먼트를 보낸다. 그리고 CLOSE_WAIT 상태에 들어간다. 클라이언트가 세그먼트를 받으면 FIN_WAIT_2 상태에 들어간다.  
3번 : 서버는 ACK를 보내고 일정 시간 이후 클라이언트에 FIN이라는 세그먼트를 보낸다.  
4번 : 클라이언트는 **TIME_WAIT** 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED상태가 된다. 이후 클라이언트는 어느정도의 시간을 대기한 후 연결이 닫히고 클라이언트와 서버의 모든 자원의 연결이 해제된다.  

**TIME_WAIT의 이유** :  
1. 지연 패킷이 발생될 경우를 대비하기 위함. 패킷이 뒤늦게 도달하고 이를 처리하지 못하면 데이터 무결성 문제가 발생하기 때문.
2. 두 장치가 연결이 닫혔는지 확인하기 위해. 만약 LAST_ACK 상태에서 닫히게 되면 다시 새로운 연결을 하려고 할때는 장치는 줄곧 LAST_ACK로 되어있기 때문에 접속 오류가 나타나게 될 것이다.  
EX) TIME_WAIT이 없을 경우
- Passive Closer의 FIN 메시지 전송
- Active Closer가 수신 후 ACK 메시지 전송 후, 통신 끊음 (Time-wait X)
- Passive Closer가 ACK를 수신하지 못함
- 일정 시간 후, ACK를 수신하지 못한 Passive Closer가 다시 FIN 메시지 전송.
- Active Closer는 이미 Closed 상태이기 때문에 FIN 메시지 수신 불가
- TCP 통신이 제대로 끊기지 않음

## TCP 헤더 구성
![image](https://user-images.githubusercontent.com/54929520/186448509-18f8ff06-918b-465d-b217-4d8f8860eee1.png)
|구분|내용|
|---|---|
|Source Port|송신측 포트번호|
|Destination Port|수신측 포트번호|
|Sequence Number|SYN Flag=1인 경우, 초기 순서 번호를 나타낸다. SYN Flag=0인 경우, 세그먼트의 순서번호.  네트워크가 불안하여 패킷을 분실, 지연 등으로 세그먼트가 순서가 어긋나게 도착 할 수 있기 때문에 sequence number를 이용하여 데이터를 올바른 순서로 재배열할 수 있다.|
|ACK Number|수신자에 의해 예상되는 다음 바이트의 순서번호(TCP통신 시 누적). 모든 데이터가 수신되었다는 것을 나타내는 묵시적인 확인 메시지 역할을 한다.|
|Offset|TCP Header의 32bit 워드 번호(TCP 헤더의 시작부터 데이터 이전까지의 길이). 헤드의 길이를 32비트 단위로 나타낸다. 최소 필드 값은 5 (5 * 32 = 160bit or 20Byte ), 최대 값 15 (15 * 32 = 480bit or 60byte).|
|Flag(Code)|URG, ACK, PSH, PST, SYN, FIN|
|Window Size|수신측이 받을 수 있는 데이터 사이즈를 수신측에서 송신측으로 전송하는 값|
|Check Sum|TCP Header를 포함한 세그먼트 전체에 대하여 계산한 값(에러체크). TCP 세그먼트의 내용이 유효한지 검증하고 손상 여부를 검사 할 수 있다.|
|Urgent Pointer|긴급히 처리해야 할 필요가 있는 데이터의 마지막 바이트의 위치|
|Option|연결이 구성되는 동안 협상할 최대 Segment 크기(MSS) 옵션을 정의|

#### Flags 필드
- CWR(Congestion Window Reduced) : 혼잡 윈도우 크기 감소
- ECN(Explicit Congestion Notification) : 혼잡을 알림
- URG(Urgent) : Urgent Pointer 필드가 가리키는 세그먼트 번호까지 긴급 데이터를 포함되어 있다는 것을 뜻한다.  이 플래그가 설정되지 않았다면 Uregent Pointer 필드는 무시되어야 한다
- ACK(Acknowledgment) : 확인 응답 메시지
- PSH(Push) : 데이터를 포함한다는 것을 뜻한다.
- RST(Reset) : 수신 거부를 하고자 할때 사용
- SYN(Synchronize) : 가상 회선이 처음 개설될 때 두 시스템의 TCP 소프트웨어는 의미 있는 확인 메시지를 전송하기 위해 일련번호를 서로 동기화해야 한다.
- FIN(Finish) : 작업이 끝나고 가상 회선을 종결하고자 할 때 사용


# UDP
UDP는 **비연결형 프로토콜**이다. 즉 할당되는 논리적 경로가 없고 각각의 패킷이 다른 경로로 전송되어 **독립적인 관계**를 갖는다.  
이로인해 패킷에 순서를 부여하여 재조립하거나 **흐름제어 및 혼잡제어를 수행하지 않아 속도가 빠르며** 네트워크 부하가 적다는 장점이 있지만 **신뢰성이 낮다.**  
연속성이 중요한 실시간 서비스(스트리밍)에 좋다.

![image](https://user-images.githubusercontent.com/54929520/186441407-7143fe6b-b55c-4f4c-bc76-6e4be44b1491.png)  
위 그림을 보면 3,2,1로 이루어진 패킷이 순서도 다르고 어떤 회선을 중심으로 이동하는 것이 아닌 따로따로 이동하여 순서도 다르게 도착한다.  

## UDP 특징
1. 비연결형 서비스로 데이터그램 방식을 제공한다.
2. 정보를 주고 받을때 정보를 보내거나 받는다는 신호절차를 거치지 안흔다.
3. UDP헤더의 Checksum 필드를 통해 최소한의 오류만 검출한다.
4. 신뢰성이 낮다.
5. TCP보다 속도가 빠르다.

## UDP 서버의 특징
1. UDP에는 연결 자체가 없어 서버 소켓과 클라이언트 소켓의 구분이 없다.
2. 소켓 대신 IP를 기반으로 데이터를 전송한다.
3. 서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다.
4. 데이터그램(메세지) 단위로 전송되며 그 크기는 65535바이트로, 크기가 초과하면 잘라서 보낸다.
5. 흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.
6. 파일 전송과 같은 신뢰성이 필요한 서비스보다 성능이 중요시 되는 경우에 사용된다.

## 용어 설명
|용어|의미|
|---|---|
|흐름제어|데이터를 송신하는 곳과 수신하는 곳의 데이터 처리속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것.|
|혼잡제어|네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것.|

## UDP 헤더
![image](https://user-images.githubusercontent.com/54929520/186451354-c842dbdd-e604-46b3-9efa-a0eaf257c3cf.png)
|구분|의미|
|--|--|
|Length|UDP Packet의 옥텟 단위 길이, UDP Header+Data|
|CheckSum|세그먼트 저체에 대한 계산값 -> 오류검출|

## TCP와 UDP의 차이
![image](https://user-images.githubusercontent.com/54929520/186442891-db336eb6-8c1f-40c8-83fe-e09d79f5eeac.png)

## 예상 질문
### TCP 관련 질문 1  
Q. TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유?  

A. Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.  

### TCP 관련 질문 2  
Q. 만약 Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?  

A. 이러한 현상에 대비하여 Client는 Server로부터 FIN 플래그를 수신하더라도 일정시간(Default: 240sec)동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT 과정)  

### TCP 관련 질문 3  
Q. 초기 Sequence Number인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유?  

A. Connection을 맺을 때 사용하는 포트(Port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순처적인 Number가 전송된다면 이전의 Connection으로부터 오는 패킷으로 인식할 수 있다. 이런 문제가 발생할 가능성을 줄이기 위해서 난수로 ISN을 설정한다. 
