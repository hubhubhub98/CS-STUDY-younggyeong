# 전송 계층
전송 계층은 송신자와 수신자를 연결하는 통신서비스를 제공하며 연결지향 데이터 스트림 지원, 신뢰성, 흐름제어를 제공하며, 애플리케이션과 인터넷계층 사이의 데이터가 전달될 때의 중계 역할을 한다.   
대표적으로 TCP와 UDP가 있다.

# TCP
TCP는 패킷 사이의 순서를 보장하고 연결지향 프로토콜을 사용해 연결을 하며 신뢰성을 구축해서 수신여부를 학인하는 **가상회선 패킷 교환 방식** 을 사용한다.
TCP는 네트워크 정보 전달을 통제하는 프로토콜이자, 인터넷을 이루는 핵심 프로토콜이다.

## 가상회선 패킷 교환 방식
![image](https://user-images.githubusercontent.com/54929520/186431876-03385ff4-8638-45f0-b76e-036e2be9fd02.png)  
위 그림과 같이 각 패킷에 가상회선 식별자가 포함되며 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 **순서대로** 도착하는 방식이다.  
**패킷이란?** 인터넷 내에서 데이터를 보내기 위한 경로배정(라우팅)을 효율적으로 하기 위해서 데이터를 여러 개의 조각들로 나누어 전송을 하는데 이때, 이 조각을 패킷이라고 한다.

## TCP의 특징
1. **연결형 서비스**로 가상 회선 방식을 제공한다.
2. **3-way handshaking과정을 통해 연결을 설정**하고 **4-way handshaking을 통해 해제**한다.
3. **흐름 제어** 및 **혼잡 제어**.
4. **높은 신뢰성**을 보장한다.
5. UDP보다 속도가 느리다.
6. 전이중(Full-Duplex), 점대점(Point to Point) 방식.

## 3-WAY HANDSHAKING
TCP는 신뢰성을 확보할 때, 3-웨이 핸드쉐이크 작업을 진행한다.

![image](https://user-images.githubusercontent.com/54929520/186432978-0c1bc7df-ea74-41e8-bdb1-283c50dcf513.png)  
1. **SYN 단계** : 클라이언트가 서버에 클라이언트의 ISN(12010)을 담아 SYN을 보낸다. ISN은 새로운 TCP 연결의 첫 번째 패킷에 할당된 임이의 시퀀스 번호를 말한다.
2. **SYN+ACK 단계** : 서버는 클라이언트의 SYN을 수신하고 서버의 ISN(5000)을 보내며 승인번호로 클라이언트의 ISN+1(12011)을 보낸다.
3. **ACK 단계** : 클라이언트는 서버의 ISN+1(5001)한 값인 승인번호를 담아 ACK를 서버에 보낸다.

**전이중 통신의 구성**
1,2번 단계를 통해 C->S 방향에 대한 연결 파라미터(시퀀스 번호)를 설정하고 승인.
1,2번 단계를 통해 S->C 방향에 대한 연결 파라미터(시퀀스 번호)를 설정하고 승인.
-> 이를 통해 전이중(full-duplec) 통신이 구성된다.

위 방식대로 3-웨이 핸드셰이크 과정 이후 신뢰성이 구축되고 데이터 전송을 시작한다.   
TCP는 이 과정이 있기에 신뢰성있는 계층이라고 하며 UDP는 이 과정이 없기에 신뢰성이 없는 계층이라고 한다.

|용어|의미|
|----|----|
|SYN|SYNchronization의 약자. 연결 요청 플래그|
|ACK|ACKnowledgement의 약자. 응답 플래그|
|ISN|Initial Sequence Number의 약어. 초기 네트워크 연결을 할 때 할당된 32비트 고유 시퀀스 번호이다.|

## 4-WAY HANDSHAKING
TCP가 연결을 해제할 때는 4-웨이 핸드쉐이크 과정이 발생한다.
![image](https://user-images.githubusercontent.com/54929520/186434592-fe30d6a1-3163-46fb-b3b5-a5d675328326.png)

1번 : 먼저 클라이언트가 연결을 닫으려고 할 때 FIN으로 설정된 세그먼트를 보낸다. 그리고 클라이언트는 FIN_WAIT_1 상태로 들어가 서버의 응답을 기다린다.  
2번 : 서버는 클라이언트로 ACK라는 승인 세그먼트를 보낸다. 그리고 CLOSE_WAIT 상태에 들어간다. 클라이언트가 세그먼트를 받으면 FIN_WAIT_2 상태에 들어간다.  
3번 : 서버는 ACK를 보내고 일정 시간 이후 클라이언트에 FIN이라는 세그먼트를 보낸다.  
4번 : 클라이언트는 **TIME_WAIT** 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED상태가 된다. 이후 클라이언트는 어느정도의 시간을 대기한 후 연결이 닫히고 클라이언트와 서버의 모든 자원의 연결이 해제된다.  

**TIME_WAIT의 이유** :  
1. 지연 패킷이 발생될 경우를 대비하기 위함. 패킷이 뒤늦게 도달하고 이를 처리하지 못하면 데이터 무결성 문제가 발생하기 때문.
2. 두 장치가 연결이 닫혔는지 확인하기 위해. 만약 LAST_ACK 상태에서 닫히게 되면 다시 새로운 연결을 하려고 할때는 장치는 줄곧 LAST_ACK로 되어있기 때문에 접속 오류가 나타나게 될 것이다.
3. 
