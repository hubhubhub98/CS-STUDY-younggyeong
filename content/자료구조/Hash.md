# 해쉬테이블(Hash map)
해시테이블이란 해시함수를 사용하여 변환한 값을 index삼아 key와 value를 저장하는 자료구조를 의미한다. 
즉 연관배열 구조를 이용하여 **키에 결과값을 저장**하는 구조이다.

**연관배열 구조**란, 키와 값이 1:1로 매핑되어 있는 자료구조를 의미한다. 따라서 key를 통해 값을 도출할 수 있다.


![image](https://user-images.githubusercontent.com/54929520/182314968-5e44975c-93ea-4342-82bb-6ec3829d3699.png)

## 해쉬테이블 특정
- 기본연산으로 search,insert,delet가 있다.
- 순차적으로 데이터를 저장하지 않음.
- 트리나 배열에 비해 속도가 획기적으로 빠르다. 모든 작업에서 평균적으로 O(1)의 시간복잡도를 갖는다.
- 커다란 데이터를 해시해서 짧은 길이로 축약할 수 있기에 데이터를 비교할 때 효율적이다.
- KEY는 UNIQUE 해야한다.
- 데이터가 저장되기 전에 저장공간을 미리 만들어야한다. 따라서 유휴공간이 발생될 가능성이 있어 공간 효율성이 좋지 않다.

## 해시함수
단방향 암호화기법으로 해시함수를 이용하여 고정된 길이의 암호화된 문자열로 바꿔버리는것을 의미한다.(역추적 불가)

KEY를 해시로 바꿔주는 역할을 한다. 서로 다른 KEY가 같은 HASH가 되는 경우를 해시 충돌이라고 하는데 해시충돌 확률을 최소화하는것이 중요하다.

## 해시 충돌
![image](https://user-images.githubusercontent.com/54929520/182315704-17ea0e92-6dab-4fbd-8375-00c79ef790e7.png)
해시 함수로 해시를 만드는 과정에서 서로 다른 key가 같은 해시로 변경되면 같은 공간에 2개의 value가 저장되므로 key-value가 1:1로 매핑되어야 하는 해시 테이블의 특성에 위배된다. 해시 충돌은 필연적으로 나타날 수 밖에 없다.

## 해시충돌 해결방법
### 1.Chaining
![image](https://user-images.githubusercontent.com/54929520/182318249-5a9d9290-b14b-4a15-b74a-034a1387e796.png)
위 그림과 같이 동일한 버킷으로 이동하여 해시 충돌이 일어날 경우 데이터를 링크드리스트로 연결하여 관리하는 방법이다.
해시테이블의 확장이 필요없고 간단하게 구현이 가능하지만 동일한 버킷에 chaining되는 데이터가 많아지면 캐시의 효율성이 감소한다.

### 2. 개방주소법
**1. 선형 탐사법**
![image](https://user-images.githubusercontent.com/54929520/182318703-6d0f57aa-a029-4cbf-b7f7-3cdbdff3c588.png)
단어 그대로 해시 충돌이 일어나면 순차적으로 고정 폭만큼 옮겨 다음 해시값에 해당하는 버킷에 액세스한다. 여기에 또 다른 데이터가 있다면 다시 이동해 액세스한다.  
이 경우에는 특정 해시 값의 주변이 채워져있는 일차 군집화 문제에 취약하다.

**2. 제곱 탐사법**
![image](https://user-images.githubusercontent.com/54929520/182318991-a27cb893-45f5-4577-9249-73c3e62bdffc.png)
선형탐사법과 동일하지만 고정폭이 아니라 **제곱**으로 늘어난다.  
데이터의 밀집도가 선형탐사법보다 낮기 때문에 일차군집화 문제에는 유리하지만 선형 탐사법보다는 캐시의 성능이 떨어져 속도의 문제가 발생할 수 있다.

**3. 이중해싱**
해시함수를 이중으로 사용한다. 최초 해시값을 얻었을 때 해시충돌이 발생하면 **다른 해시함수를 이용해 탐사이동폭**을 얻는 방법이다.
최초 해시값이 같더라도 탐사 이동폭이 달라지고, 탐사 이동폭이 같더라도 최초 해시값이 달라져 위의 두 방법을 모두 완화한다.

## JAVA에서의 HashMap과 HashTable의 차이점
**1. 보조해시함수**

HashMap은 보조 해시함수를 사용하기 때문에 해시 충돌이 덜 발생한다.

**2. 동기화**

HashMap의 경우 동기화를 지원하지 않는다. 그래서 HashTable은 동기화처리때문에 HashMap보다 더 느리다고 한다.

멀티쓰레드 환경에서도 보통 동기화를 지원하는 HashTable을 쓰기보다는 
~~~java
Map m == Collections.syschronizedMap(new HashpMap());
~~~
과 같은 형태가 더 선호된다고 한다.
