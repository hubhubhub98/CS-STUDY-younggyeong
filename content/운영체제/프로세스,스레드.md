# 프로세스
프로세스는 컴퓨터에서 실행되고 있는 프로그램을 말하며 CPU 스케줄링의 대상이 되는 작업이라는 용어와 같은 의미로 쓰인다.

## 프로세스의 컴파일 과정
![image](https://user-images.githubusercontent.com/54929520/189055871-8f7e3a44-4d42-4bc6-881a-510674ab22ba.png)

1. 전처리  
소스코드의 주석을 제거하고 #include 등 헤더파일을 병합하여 매크로를 치환.

2. 컴파일러  
오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환한다.

3. 어셈블러  
어셈블리어를 목적코드로 변환한다. 이때 확장자는 운영체제마다 다르고 리눅스에서는 .o이다.

4. 링커  
프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만든다.

 
**참고사항*  
*정적 라이브러리 : 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식이며 외부 의존도가 낮고 코드 중복 등 메모리 효율성이 떨어진다.*  
*동적 라이브러리 : 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조하는 방식이며, 메모리 효율성에서의 장점과 외부 의존도가 높아진다는 단점이 있다.*  

## 프로세스의 상태
![image](https://user-images.githubusercontent.com/54929520/189057021-111c5b12-46a4-48f1-a4a0-980f0f2b1fb6.png)

**1. 생성**  
생성상태는 프로세스가 생성된 상태를 의미하며 fork()나 exec()함수를 통해 생성한다.

**2. 준비**  
필요한 모든 자원을 할당받은 상태로서, 프로세스가 CPU 스케줄러로부터 CPU 소유권을 얻을 때까지 자신의 차례를 순서대로 기다리는 상태이다. 이렇게 준비상태로 가는것을 dispatch라고 한다.

**3. 실행**  
프로세스에 의해 실행되고 있는 상태를 의미한다. 시간할당량이 끝나거나 우선순위가 높은 프로세스가 들어오면 preemption으로 프로세스를 반납하고 준비상태로 전이(wake-up)된다.

**4. 대기**  
자원을 요청 후 할당받을 때 까지 기다리는 상태를 뜯하며 할당되면 준비상태로 전이된다.

**5. 지연 준비**  
준비상태에 있던 프로세스가 기억장치를 잃은 상태이다. 이를 swap-out이라고 한다. 거꾸로 지연 준비상태에서 기억장치를 할당받아 준비상태로 가는것을 swap-in 이라고 한다.

**6. 지연 대기**  
지연 준비와 마찬가지로 대기상태에서 기억장치를 잃은 상태이다. 
  
**7. 종료**  
프로세스의 실행이 완료되어 메모리와 CPU 소유권을 모두 높고 가는 상태.

## 프로세스의 메모리 구조
![image](https://user-images.githubusercontent.com/54929520/189059298-315eaa6a-7dc2-4fe9-833e-ce0af0435115.png)

### 스택
스택에는 지역변수, 매개변수, 함수가 저장되고 **컴파일 시에** 크기가 결정되며 동적인 특징을 갖는다. 보통 힙과 인접한 방향으로 커지며, 스택 포인터와 힙 포인터가 만나면 메모리가 소진되었다는것을 의미한다.

### 힙
힙은 동적할당(malloc, calloc) 할 때 사용되며 **런타임 시에** 크기가 결정된다. 예를 들어 벡터같은 동적 배열은 힙에 동적 할당된다.

### 데이터 영역
전역변수, 정적변수가 저장되며 프로그램이 종료되면 사라지는 변수가 들어가있는 영역이다.

### 텍스트(코드)영역
프로그램에 내장되어 있는 소스코드가 들어가는 영역이다. 이 영역은 수정이 불가능한 기계어로 저장되어 있어 프로그램이 기계영역을 침범해 쓰기를 시도할 경우 오류가 발생한다.

## PCB(프로세스 제어 블록)
![image](https://user-images.githubusercontent.com/54929520/189060873-35d05603-2438-4b78-aabe-e30786c3b31f.png)
PCB는 운영체제에서 프로세스에 대한 메타데이터를 저장한 '데이터'를 의미한다. 프로세스 제어 블록이라고도 하며 프로세스가 생성되면 운영체제는 해당 PCB를 생성한다.

## PCB의 구조
**1. 프로세스 상태**  
프로세스의 상태를 기록해둔다.

**2. 프로세스 ID**  
pid_t라는 데이터 타입의 pid를 저장해둔다.

**3. 프로그램 카운터**  
프로세스에서 실행해야 할 다음 명령어의 주소를 저장해둔다.

**4. CPU register**   
CPU에서 실행하기 위해 저장해야 할 레지스터의 값을 잃지 않기 위해서 PCB에 레지스터 값을 저장하고 다시 프로세스가 호출되었을 때 사용하기 위해 이를 저장한다.

**5. CPU 스케쥴링 정보**  
우선순위와 최종 실행 시각, CPU 점유 시간 등을 저장해둔다.
CPU 스케줄링의 결정 시점은 다음과 같은 상태 변화가 있을 때이다.  
Running → Waiting  
Running → Ready  
Waiting → Ready  
Running → Terminate  

**6. 메모리 관리 정보**
프로세스의 현재 주소와 주소공간을 갖고있다.

**7. 계정 정보**
프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보

**8. I/O 상태정보**
프로세스에 할당된 I/O 디바이스의 목록.

## 컨텍스트 스위칭
컨텍스트 스위칭은 앞서 설명한 PCB를 교환하는 과정을 말한다. 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생한다. 컴퓨터는 여러 프로그램을 동시에 실행하는것 처럼 보이지만 어떠한 시점에서 실행되고 있는 프로세스는 한개이며, 많은 프로세스가 동시에 구동되는 것처럼 보이는 이유는 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른속도로 실행되기 때문이다.  

![image](https://user-images.githubusercontent.com/54929520/189064311-bf44f04c-2470-42d8-a397-9c3599929314.png)

그림처럼 한개의 프로세스 A가 실행하다 멈추고, **프로세스 A의 PCB를 저장하고 프로세스 B를 로드**하여 실행한다. 다시 스위칭이 일어나면 **B의 PCB를 저장하고 A의 PCB를 로드**한다. 컨텍스트 스위칭이 일어날 때 **유휴시간이 발생하며 캐시미스**가 발생한다.

*캐시미스 : CPU가 캐시 메모리에 접근했을 때 캐시 메모리가 해당 데이터를 갖고 있지 않으면 캐시미스가 발생했다고 한다.*

**최종 정리**
1. p1 실행, p2 준비
2. p1 타임아웃
3. p1의 상태를 pcb1에 저장, pcb2에서 p2의 상태를 가져옴
4. p2 디스패치
5. p2 실행, p1 준비
6. p2 타임아웃
7. p2의 상태를 pcb2에 저장, pcb1에서 p1의 상태를 가져옴
8. p1 디스패치

# 스레드
![image](https://user-images.githubusercontent.com/54929520/189065961-43a5894d-a756-4c87-9e00-d87a31171bb9.png)

스레드는 경량 프로세스라고도 불리며, 프로세스 내에서 실행되는 프로그램 코드의 흐름을 의미한다. 프로세스 내 주소 공간이나 자원 공유가 가능하다.

- 스레스는 프로세스 내의 CODE,DATA,HEAP 영역을 공유하고 STACK영역만 따로 할당받는다.
- 스레드는 별도의 Register와 Stack을 갖고, 한 스레드가 프로세스 자원을 변경하면 다른 스레드도 그 변경 결과를 가져올 수 있다.

## 스레드가 필요한 이유
여러개의 작업 단위로 구성된 프로그램에서 요청을 동시에 처리하기 위함이다.

## 스레드의 이점
**1. 응답성**  
다른 스레드의 실행시간이 길거나 입출력 요청으로 인해 block 되더라도 계속 실행되는것을 허용한다.

**2. 자원 공유**  
프로세스 내 자원을 공유한다.

**3. 경제성**  
프로세스 생성을 위한 비용보다 스레드 생성을 위한 비용이 훨씬 적다. (컨텍스트 스위칭 비용도 스레드가 유리함.)

**4. 확장성**  
멀티 프로세서 구조에서는 스레드들이 각자 다른 프로세서 위에서 병렬적으로 실행되기 때문에, 다중 CPU환경에서 병렬성이 크게 증대된다.

## TCB
프로세스에 PCB가 있듯이 쓰레드도 TCB에 정보를 저장한다.

## 스레드의 구현
![image](https://user-images.githubusercontent.com/54929520/189072217-0489b2ed-1a24-4b6f-b332-887322d43e1e.png)

쓰레드는 운영체제에 따라 다양하게 구현 가능한데, 3가지 형태로 구분한다.

**1. 사용자 수준 쓰레드-다대일 매핑**

사용자 영역의 쓰레드 라이브러리로 구현하고 쓰레드와 관련된 모든 행위를 사용자 영역에서 하므로 **커널이 쓰레드의 존재를 알지 못한다.**  
쓰레드 교환에 커널이 개입하지 않아 커널에서 사용자 영역으로 전환이 필요없다. 커널은 쓰레드가 아닌 프로세스를 한 단위로 인식하고 프로세서를 할당한다. 다수의 **사용자 수준 쓰레드가 하나의 커널 수준 쓰레드에 매핑되므로 다대일 쓰레드 매핑**이라고 한다.

**장점**
1. 이식성이 높다.(모든 운영체제에 적용 가능)
2. 오버헤드가 적다.(커널 호출 X)
3. 유연한 스케쥴링 가능(쓰레드 라이브러리에서 스케줄링을 제어하므로 프로그램에 맞게 스케줄링 가능)

**단점**
1. 동시성을 지원하지 않음(프로세스 단위로 프로세서를 할당하여 동일한 프로세스의 쓰레드 한개가 대기상태가 되면 이 중 어떤 쓰레드도 작동하지 않음.)
2. 확장에 제약이 있음
3. 쓰레드 간 보호 불가능(쓰레드 간 보호에 커널의 보호방법을 사용할 수 없다.)


**2. 커널 수준 쓰레드-일대일 매핑**   
사용자 수준 쓰레드의 한계를 극복하는 방법으로, 커널이 쓰레드와 관련되 모든 작업을 관리한다. 한 프로세스에서 다수의 쓰레드가 프로세서를 할당받아 병행으로 수행하고, 쓰레드 한 개가 대기 상태가 되면 동일한 프로세스에 속한 다른 쓰레드로 교환이 가능하다. 커널 수준 쓰레드는 사용자 수준 쓰레드와 커널 수준 쓰레드가 일대일로 매핑된다. 따라서 사용자 수준 쓰레드를 생성하면 이에 대응하는 커널 쓰레드를 자동으로 생성한다.

**3. 혼합형 쓰레드-다대다 매핑**   
![image](https://user-images.githubusercontent.com/54929520/189077673-7e55e6e6-177c-4de8-8444-adbd4951a88c.png)

혼합형 쓰레드는 사용자 수준 쓰레드와 커널 수준 쓰레드를 혼합한 구조이다. 시스템 호출을 할 때 다른 쓰레드를 중단하는 다대일 매핑의 사용자 수준 쓰레드와 쓰레드 수를 제한하는 일대일 매핑의 커널 수준 쓰레드 문제를 극복하는 방법이다.  
프로세스 하나에 경량 프로세스가 하나 이상 있고, 경량프로세스에는 이에 대응하는 커널 쓰레드가 한개 있다. 따라서 프로세스는 입출력을 완료할 때까지 대기할 필요가 없다.